// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: jhnet.proto
// Protobuf C++ Version: 5.29.3

#ifndef jhnet_2eproto_2epb_2eh
#define jhnet_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_jhnet_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_jhnet_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_jhnet_2eproto;
namespace jhnet {
class CSP_CharList;
struct CSP_CharListDefaultTypeInternal;
extern CSP_CharListDefaultTypeInternal _CSP_CharList_default_instance_;
class CSP_CreateChar;
struct CSP_CreateCharDefaultTypeInternal;
extern CSP_CreateCharDefaultTypeInternal _CSP_CreateChar_default_instance_;
class CSP_Echo;
struct CSP_EchoDefaultTypeInternal;
extern CSP_EchoDefaultTypeInternal _CSP_Echo_default_instance_;
class CSP_Login;
struct CSP_LoginDefaultTypeInternal;
extern CSP_LoginDefaultTypeInternal _CSP_Login_default_instance_;
class CSP_MapLoadEnd;
struct CSP_MapLoadEndDefaultTypeInternal;
extern CSP_MapLoadEndDefaultTypeInternal _CSP_MapLoadEnd_default_instance_;
class CSP_Move;
struct CSP_MoveDefaultTypeInternal;
extern CSP_MoveDefaultTypeInternal _CSP_Move_default_instance_;
class CSP_Ping;
struct CSP_PingDefaultTypeInternal;
extern CSP_PingDefaultTypeInternal _CSP_Ping_default_instance_;
class CSP_SelectChar;
struct CSP_SelectCharDefaultTypeInternal;
extern CSP_SelectCharDefaultTypeInternal _CSP_SelectChar_default_instance_;
class CharacterInfo;
struct CharacterInfoDefaultTypeInternal;
extern CharacterInfoDefaultTypeInternal _CharacterInfo_default_instance_;
class MyPlayerDetailInfo;
struct MyPlayerDetailInfoDefaultTypeInternal;
extern MyPlayerDetailInfoDefaultTypeInternal _MyPlayerDetailInfo_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PosInfo;
struct PosInfoDefaultTypeInternal;
extern PosInfoDefaultTypeInternal _PosInfo_default_instance_;
class SCP_CharList;
struct SCP_CharListDefaultTypeInternal;
extern SCP_CharListDefaultTypeInternal _SCP_CharList_default_instance_;
class SCP_CreateChar;
struct SCP_CreateCharDefaultTypeInternal;
extern SCP_CreateCharDefaultTypeInternal _SCP_CreateChar_default_instance_;
class SCP_Despawn;
struct SCP_DespawnDefaultTypeInternal;
extern SCP_DespawnDefaultTypeInternal _SCP_Despawn_default_instance_;
class SCP_Echo;
struct SCP_EchoDefaultTypeInternal;
extern SCP_EchoDefaultTypeInternal _SCP_Echo_default_instance_;
class SCP_EnterGame;
struct SCP_EnterGameDefaultTypeInternal;
extern SCP_EnterGameDefaultTypeInternal _SCP_EnterGame_default_instance_;
class SCP_Login;
struct SCP_LoginDefaultTypeInternal;
extern SCP_LoginDefaultTypeInternal _SCP_Login_default_instance_;
class SCP_Move;
struct SCP_MoveDefaultTypeInternal;
extern SCP_MoveDefaultTypeInternal _SCP_Move_default_instance_;
class SCP_MyCharacterInfo;
struct SCP_MyCharacterInfoDefaultTypeInternal;
extern SCP_MyCharacterInfoDefaultTypeInternal _SCP_MyCharacterInfo_default_instance_;
class SCP_Ping;
struct SCP_PingDefaultTypeInternal;
extern SCP_PingDefaultTypeInternal _SCP_Ping_default_instance_;
class SCP_SelectCharResult;
struct SCP_SelectCharResultDefaultTypeInternal;
extern SCP_SelectCharResultDefaultTypeInternal _SCP_SelectCharResult_default_instance_;
class SCP_Spawn;
struct SCP_SpawnDefaultTypeInternal;
extern SCP_SpawnDefaultTypeInternal _SCP_Spawn_default_instance_;
}  // namespace jhnet
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace jhnet {
enum PacketId : int {
  PACKET_ID_NONE = 0,
  C2S_PING = 1001,
  C2S_ECHO = 1002,
  C2S_LOGIN = 1003,
  C2S_CHAR_LIST = 1004,
  C2S_CREATE_CHAR = 1005,
  C2S_SELECT_CHAR = 1006,
  C2S_MAP_LOAD_END = 1007,
  C2S_MOVE = 1008,
  S2C_PING = 2001,
  S2C_ECHO = 2002,
  S2C_LOGIN = 2003,
  S2C_CHAR_LIST = 2004,
  S2C_CREATE_CHAR = 2005,
  S2C_SELECT_CHAR_RESULT = 2006,
  S2C_MY_CHARACTER_INFO = 2007,
  S2C_ENTER_GAME = 2008,
  S2C_SPAWN = 2009,
  S2C_DESPAWN = 2010,
  S2C_MOVE = 2011,
  PacketId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PacketId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PacketId_IsValid(int value);
extern const uint32_t PacketId_internal_data_[];
constexpr PacketId PacketId_MIN = static_cast<PacketId>(0);
constexpr PacketId PacketId_MAX = static_cast<PacketId>(2011);
constexpr int PacketId_ARRAYSIZE = 2011 + 1;
const ::google::protobuf::EnumDescriptor*
PacketId_descriptor();
template <typename T>
const std::string& PacketId_Name(T value) {
  static_assert(std::is_same<T, PacketId>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PacketId_Name().");
  return ::google::protobuf::internal::NameOfEnum(PacketId_descriptor(), value);
}
inline bool PacketId_Parse(absl::string_view name, PacketId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketId>(
      PacketId_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SCP_SelectCharResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_SelectCharResult) */ {
 public:
  inline SCP_SelectCharResult() : SCP_SelectCharResult(nullptr) {}
  ~SCP_SelectCharResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_SelectCharResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_SelectCharResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_SelectCharResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_SelectCharResult(const SCP_SelectCharResult& from) : SCP_SelectCharResult(nullptr, from) {}
  inline SCP_SelectCharResult(SCP_SelectCharResult&& from) noexcept
      : SCP_SelectCharResult(nullptr, std::move(from)) {}
  inline SCP_SelectCharResult& operator=(const SCP_SelectCharResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_SelectCharResult& operator=(SCP_SelectCharResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_SelectCharResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_SelectCharResult* internal_default_instance() {
    return reinterpret_cast<const SCP_SelectCharResult*>(
        &_SCP_SelectCharResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(SCP_SelectCharResult& a, SCP_SelectCharResult& b) { a.Swap(&b); }
  inline void Swap(SCP_SelectCharResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_SelectCharResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_SelectCharResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_SelectCharResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_SelectCharResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_SelectCharResult& from) { SCP_SelectCharResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_SelectCharResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_SelectCharResult"; }

 protected:
  explicit SCP_SelectCharResult(::google::protobuf::Arena* arena);
  SCP_SelectCharResult(::google::protobuf::Arena* arena, const SCP_SelectCharResult& from);
  SCP_SelectCharResult(::google::protobuf::Arena* arena, SCP_SelectCharResult&& from) noexcept
      : SCP_SelectCharResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_SelectCharResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_SelectCharResult& from_msg);
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_Ping) */ {
 public:
  inline SCP_Ping() : SCP_Ping(nullptr) {}
  ~SCP_Ping() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_Ping* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_Ping));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_Ping(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_Ping(const SCP_Ping& from) : SCP_Ping(nullptr, from) {}
  inline SCP_Ping(SCP_Ping&& from) noexcept
      : SCP_Ping(nullptr, std::move(from)) {}
  inline SCP_Ping& operator=(const SCP_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_Ping& operator=(SCP_Ping&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_Ping* internal_default_instance() {
    return reinterpret_cast<const SCP_Ping*>(
        &_SCP_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SCP_Ping& a, SCP_Ping& b) { a.Swap(&b); }
  inline void Swap(SCP_Ping* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_Ping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_Ping* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_Ping& from) { SCP_Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_Ping* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_Ping"; }

 protected:
  explicit SCP_Ping(::google::protobuf::Arena* arena);
  SCP_Ping(::google::protobuf::Arena* arena, const SCP_Ping& from);
  SCP_Ping(::google::protobuf::Arena* arena, SCP_Ping&& from) noexcept
      : SCP_Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 2,
    kNumberFieldNumber = 1,
  };
  // uint64 timestamp = 2;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 number = 1;
  void clear_number() ;
  ::uint32_t number() const;
  void set_number(::uint32_t value);

  private:
  ::uint32_t _internal_number() const;
  void _internal_set_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_Ping& from_msg);
    ::uint64_t timestamp_;
    ::uint32_t number_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_Login final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_Login) */ {
 public:
  inline SCP_Login() : SCP_Login(nullptr) {}
  ~SCP_Login() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_Login* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_Login));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_Login(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_Login(const SCP_Login& from) : SCP_Login(nullptr, from) {}
  inline SCP_Login(SCP_Login&& from) noexcept
      : SCP_Login(nullptr, std::move(from)) {}
  inline SCP_Login& operator=(const SCP_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_Login& operator=(SCP_Login&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_Login* internal_default_instance() {
    return reinterpret_cast<const SCP_Login*>(
        &_SCP_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SCP_Login& a, SCP_Login& b) { a.Swap(&b); }
  inline void Swap(SCP_Login* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_Login* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_Login* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_Login>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_Login& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_Login& from) { SCP_Login::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_Login* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_Login"; }

 protected:
  explicit SCP_Login(::google::protobuf::Arena* arena);
  SCP_Login(::google::protobuf::Arena* arena, const SCP_Login& from);
  SCP_Login(::google::protobuf::Arena* arena, SCP_Login&& from) noexcept
      : SCP_Login(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorMessageFieldNumber = 2,
    kLoginOkFieldNumber = 1,
    kAccountUidFieldNumber = 3,
  };
  // string error_message = 2;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // bool login_ok = 1;
  void clear_login_ok() ;
  bool login_ok() const;
  void set_login_ok(bool value);

  private:
  bool _internal_login_ok() const;
  void _internal_set_login_ok(bool value);

  public:
  // uint32 account_uid = 3;
  void clear_account_uid() ;
  ::uint32_t account_uid() const;
  void set_account_uid(::uint32_t value);

  private:
  ::uint32_t _internal_account_uid() const;
  void _internal_set_account_uid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_Login)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_Login& from_msg);
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    bool login_ok_;
    ::uint32_t account_uid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_Echo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_Echo) */ {
 public:
  inline SCP_Echo() : SCP_Echo(nullptr) {}
  ~SCP_Echo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_Echo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_Echo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_Echo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_Echo(const SCP_Echo& from) : SCP_Echo(nullptr, from) {}
  inline SCP_Echo(SCP_Echo&& from) noexcept
      : SCP_Echo(nullptr, std::move(from)) {}
  inline SCP_Echo& operator=(const SCP_Echo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_Echo& operator=(SCP_Echo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_Echo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_Echo* internal_default_instance() {
    return reinterpret_cast<const SCP_Echo*>(
        &_SCP_Echo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SCP_Echo& a, SCP_Echo& b) { a.Swap(&b); }
  inline void Swap(SCP_Echo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_Echo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_Echo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_Echo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_Echo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_Echo& from) { SCP_Echo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_Echo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_Echo"; }

 protected:
  explicit SCP_Echo(::google::protobuf::Arena* arena);
  SCP_Echo(::google::protobuf::Arena* arena, const SCP_Echo& from);
  SCP_Echo(::google::protobuf::Arena* arena, SCP_Echo&& from) noexcept
      : SCP_Echo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kNumberFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // uint32 number = 1;
  void clear_number() ;
  ::uint32_t number() const;
  void set_number(::uint32_t value);

  private:
  ::uint32_t _internal_number() const;
  void _internal_set_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_Echo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      30, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_Echo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint32_t number_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_Despawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_Despawn) */ {
 public:
  inline SCP_Despawn() : SCP_Despawn(nullptr) {}
  ~SCP_Despawn() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_Despawn* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_Despawn));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_Despawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_Despawn(const SCP_Despawn& from) : SCP_Despawn(nullptr, from) {}
  inline SCP_Despawn(SCP_Despawn&& from) noexcept
      : SCP_Despawn(nullptr, std::move(from)) {}
  inline SCP_Despawn& operator=(const SCP_Despawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_Despawn& operator=(SCP_Despawn&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_Despawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_Despawn* internal_default_instance() {
    return reinterpret_cast<const SCP_Despawn*>(
        &_SCP_Despawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(SCP_Despawn& a, SCP_Despawn& b) { a.Swap(&b); }
  inline void Swap(SCP_Despawn* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_Despawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_Despawn* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_Despawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_Despawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_Despawn& from) { SCP_Despawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_Despawn* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_Despawn"; }

 protected:
  explicit SCP_Despawn(::google::protobuf::Arena* arena);
  SCP_Despawn(::google::protobuf::Arena* arena, const SCP_Despawn& from);
  SCP_Despawn(::google::protobuf::Arena* arena, SCP_Despawn&& from) noexcept
      : SCP_Despawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldUniqueFieldNumber = 1,
  };
  // repeated uint64 field_unique = 1;
  int field_unique_size() const;
  private:
  int _internal_field_unique_size() const;

  public:
  void clear_field_unique() ;
  ::uint64_t field_unique(int index) const;
  void set_field_unique(int index, ::uint64_t value);
  void add_field_unique(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& field_unique() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_field_unique();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_field_unique() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_field_unique();

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_Despawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_Despawn& from_msg);
    ::google::protobuf::RepeatedField<::uint64_t> field_unique_;
    ::google::protobuf::internal::CachedSize _field_unique_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_CreateChar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_CreateChar) */ {
 public:
  inline SCP_CreateChar() : SCP_CreateChar(nullptr) {}
  ~SCP_CreateChar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_CreateChar* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_CreateChar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_CreateChar(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_CreateChar(const SCP_CreateChar& from) : SCP_CreateChar(nullptr, from) {}
  inline SCP_CreateChar(SCP_CreateChar&& from) noexcept
      : SCP_CreateChar(nullptr, std::move(from)) {}
  inline SCP_CreateChar& operator=(const SCP_CreateChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_CreateChar& operator=(SCP_CreateChar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_CreateChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_CreateChar* internal_default_instance() {
    return reinterpret_cast<const SCP_CreateChar*>(
        &_SCP_CreateChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SCP_CreateChar& a, SCP_CreateChar& b) { a.Swap(&b); }
  inline void Swap(SCP_CreateChar* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_CreateChar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_CreateChar* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_CreateChar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_CreateChar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_CreateChar& from) { SCP_CreateChar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_CreateChar* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_CreateChar"; }

 protected:
  explicit SCP_CreateChar(::google::protobuf::Arena* arena);
  SCP_CreateChar(::google::protobuf::Arena* arena, const SCP_CreateChar& from);
  SCP_CreateChar(::google::protobuf::Arena* arena, SCP_CreateChar&& from) noexcept
      : SCP_CreateChar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorMessageFieldNumber = 2,
    kCreateOkFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // bool create_ok = 1;
  void clear_create_ok() ;
  bool create_ok() const;
  void set_create_ok(bool value);

  private:
  bool _internal_create_ok() const;
  void _internal_set_create_ok(bool value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_CreateChar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_CreateChar& from_msg);
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    bool create_ok_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class PosInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.PosInfo) */ {
 public:
  inline PosInfo() : PosInfo(nullptr) {}
  ~PosInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PosInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PosInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PosInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PosInfo(const PosInfo& from) : PosInfo(nullptr, from) {}
  inline PosInfo(PosInfo&& from) noexcept
      : PosInfo(nullptr, std::move(from)) {}
  inline PosInfo& operator=(const PosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PosInfo& operator=(PosInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PosInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PosInfo* internal_default_instance() {
    return reinterpret_cast<const PosInfo*>(
        &_PosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(PosInfo& a, PosInfo& b) { a.Swap(&b); }
  inline void Swap(PosInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PosInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PosInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PosInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PosInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PosInfo& from) { PosInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PosInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.PosInfo"; }

 protected:
  explicit PosInfo(::google::protobuf::Arena* arena);
  PosInfo(::google::protobuf::Arena* arena, const PosInfo& from);
  PosInfo(::google::protobuf::Arena* arena, PosInfo&& from) noexcept
      : PosInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kDirFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // int32 dir = 3;
  void clear_dir() ;
  ::int32_t dir() const;
  void set_dir(::int32_t value);

  private:
  ::int32_t _internal_dir() const;
  void _internal_set_dir(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.PosInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PosInfo& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    ::int32_t dir_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class MyPlayerDetailInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.MyPlayerDetailInfo) */ {
 public:
  inline MyPlayerDetailInfo() : MyPlayerDetailInfo(nullptr) {}
  ~MyPlayerDetailInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MyPlayerDetailInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MyPlayerDetailInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MyPlayerDetailInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline MyPlayerDetailInfo(const MyPlayerDetailInfo& from) : MyPlayerDetailInfo(nullptr, from) {}
  inline MyPlayerDetailInfo(MyPlayerDetailInfo&& from) noexcept
      : MyPlayerDetailInfo(nullptr, std::move(from)) {}
  inline MyPlayerDetailInfo& operator=(const MyPlayerDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyPlayerDetailInfo& operator=(MyPlayerDetailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyPlayerDetailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyPlayerDetailInfo* internal_default_instance() {
    return reinterpret_cast<const MyPlayerDetailInfo*>(
        &_MyPlayerDetailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(MyPlayerDetailInfo& a, MyPlayerDetailInfo& b) { a.Swap(&b); }
  inline void Swap(MyPlayerDetailInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyPlayerDetailInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyPlayerDetailInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MyPlayerDetailInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MyPlayerDetailInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MyPlayerDetailInfo& from) { MyPlayerDetailInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MyPlayerDetailInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.MyPlayerDetailInfo"; }

 protected:
  explicit MyPlayerDetailInfo(::google::protobuf::Arena* arena);
  MyPlayerDetailInfo(::google::protobuf::Arena* arena, const MyPlayerDetailInfo& from);
  MyPlayerDetailInfo(::google::protobuf::Arena* arena, MyPlayerDetailInfo&& from) noexcept
      : MyPlayerDetailInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLevelFieldNumber = 1,
    kJobCodeFieldNumber = 2,
    kExpFieldNumber = 3,
    kHpFieldNumber = 4,
    kMaxHpFieldNumber = 5,
    kDamageFieldNumber = 6,
    kDefenseFieldNumber = 7,
    kGoldFieldNumber = 8,
  };
  // int32 level = 1;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // int32 job_code = 2;
  void clear_job_code() ;
  ::int32_t job_code() const;
  void set_job_code(::int32_t value);

  private:
  ::int32_t _internal_job_code() const;
  void _internal_set_job_code(::int32_t value);

  public:
  // int64 exp = 3;
  void clear_exp() ;
  ::int64_t exp() const;
  void set_exp(::int64_t value);

  private:
  ::int64_t _internal_exp() const;
  void _internal_set_exp(::int64_t value);

  public:
  // int32 hp = 4;
  void clear_hp() ;
  ::int32_t hp() const;
  void set_hp(::int32_t value);

  private:
  ::int32_t _internal_hp() const;
  void _internal_set_hp(::int32_t value);

  public:
  // int32 max_hp = 5;
  void clear_max_hp() ;
  ::int32_t max_hp() const;
  void set_max_hp(::int32_t value);

  private:
  ::int32_t _internal_max_hp() const;
  void _internal_set_max_hp(::int32_t value);

  public:
  // int32 damage = 6;
  void clear_damage() ;
  ::int32_t damage() const;
  void set_damage(::int32_t value);

  private:
  ::int32_t _internal_damage() const;
  void _internal_set_damage(::int32_t value);

  public:
  // int32 defense = 7;
  void clear_defense() ;
  ::int32_t defense() const;
  void set_defense(::int32_t value);

  private:
  ::int32_t _internal_defense() const;
  void _internal_set_defense(::int32_t value);

  public:
  // int64 gold = 8;
  void clear_gold() ;
  ::int64_t gold() const;
  void set_gold(::int64_t value);

  private:
  ::int64_t _internal_gold() const;
  void _internal_set_gold(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.MyPlayerDetailInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MyPlayerDetailInfo& from_msg);
    ::int32_t level_;
    ::int32_t job_code_;
    ::int64_t exp_;
    ::int32_t hp_;
    ::int32_t max_hp_;
    ::int32_t damage_;
    ::int32_t defense_;
    ::int64_t gold_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CharacterInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.CharacterInfo) */ {
 public:
  inline CharacterInfo() : CharacterInfo(nullptr) {}
  ~CharacterInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CharacterInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CharacterInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CharacterInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CharacterInfo(const CharacterInfo& from) : CharacterInfo(nullptr, from) {}
  inline CharacterInfo(CharacterInfo&& from) noexcept
      : CharacterInfo(nullptr, std::move(from)) {}
  inline CharacterInfo& operator=(const CharacterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterInfo& operator=(CharacterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterInfo* internal_default_instance() {
    return reinterpret_cast<const CharacterInfo*>(
        &_CharacterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CharacterInfo& a, CharacterInfo& b) { a.Swap(&b); }
  inline void Swap(CharacterInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CharacterInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CharacterInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CharacterInfo& from) { CharacterInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CharacterInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CharacterInfo"; }

 protected:
  explicit CharacterInfo(::google::protobuf::Arena* arena);
  CharacterInfo(::google::protobuf::Arena* arena, const CharacterInfo& from);
  CharacterInfo(::google::protobuf::Arena* arena, CharacterInfo&& from) noexcept
      : CharacterInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kCharacterUidFieldNumber = 1,
    kLevelFieldNumber = 3,
    kJobCodeFieldNumber = 4,
  };
  // string nickname = 2;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // uint64 character_uid = 1;
  void clear_character_uid() ;
  ::uint64_t character_uid() const;
  void set_character_uid(::uint64_t value);

  private:
  ::uint64_t _internal_character_uid() const;
  void _internal_set_character_uid(::uint64_t value);

  public:
  // int32 level = 3;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // int32 job_code = 4;
  void clear_job_code() ;
  ::int32_t job_code() const;
  void set_job_code(::int32_t value);

  private:
  ::int32_t _internal_job_code() const;
  void _internal_set_job_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.CharacterInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      36, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CharacterInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint64_t character_uid_;
    ::int32_t level_;
    ::int32_t job_code_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_SelectChar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.CSP_SelectChar) */ {
 public:
  inline CSP_SelectChar() : CSP_SelectChar(nullptr) {}
  ~CSP_SelectChar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_SelectChar* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_SelectChar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_SelectChar(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_SelectChar(const CSP_SelectChar& from) : CSP_SelectChar(nullptr, from) {}
  inline CSP_SelectChar(CSP_SelectChar&& from) noexcept
      : CSP_SelectChar(nullptr, std::move(from)) {}
  inline CSP_SelectChar& operator=(const CSP_SelectChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_SelectChar& operator=(CSP_SelectChar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_SelectChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_SelectChar* internal_default_instance() {
    return reinterpret_cast<const CSP_SelectChar*>(
        &_CSP_SelectChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CSP_SelectChar& a, CSP_SelectChar& b) { a.Swap(&b); }
  inline void Swap(CSP_SelectChar* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_SelectChar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_SelectChar* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CSP_SelectChar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CSP_SelectChar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CSP_SelectChar& from) { CSP_SelectChar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CSP_SelectChar* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_SelectChar"; }

 protected:
  explicit CSP_SelectChar(::google::protobuf::Arena* arena);
  CSP_SelectChar(::google::protobuf::Arena* arena, const CSP_SelectChar& from);
  CSP_SelectChar(::google::protobuf::Arena* arena, CSP_SelectChar&& from) noexcept
      : CSP_SelectChar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterUidFieldNumber = 1,
  };
  // uint64 character_uid = 1;
  void clear_character_uid() ;
  ::uint64_t character_uid() const;
  void set_character_uid(::uint64_t value);

  private:
  ::uint64_t _internal_character_uid() const;
  void _internal_set_character_uid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.CSP_SelectChar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_SelectChar& from_msg);
    ::uint64_t character_uid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.CSP_Ping) */ {
 public:
  inline CSP_Ping() : CSP_Ping(nullptr) {}
  ~CSP_Ping() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_Ping* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_Ping));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_Ping(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_Ping(const CSP_Ping& from) : CSP_Ping(nullptr, from) {}
  inline CSP_Ping(CSP_Ping&& from) noexcept
      : CSP_Ping(nullptr, std::move(from)) {}
  inline CSP_Ping& operator=(const CSP_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_Ping& operator=(CSP_Ping&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_Ping* internal_default_instance() {
    return reinterpret_cast<const CSP_Ping*>(
        &_CSP_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(CSP_Ping& a, CSP_Ping& b) { a.Swap(&b); }
  inline void Swap(CSP_Ping* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_Ping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_Ping* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CSP_Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CSP_Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CSP_Ping& from) { CSP_Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CSP_Ping* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_Ping"; }

 protected:
  explicit CSP_Ping(::google::protobuf::Arena* arena);
  CSP_Ping(::google::protobuf::Arena* arena, const CSP_Ping& from);
  CSP_Ping(::google::protobuf::Arena* arena, CSP_Ping&& from) noexcept
      : CSP_Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 2,
    kNumberFieldNumber = 1,
  };
  // uint64 timestamp = 2;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 number = 1;
  void clear_number() ;
  ::uint32_t number() const;
  void set_number(::uint32_t value);

  private:
  ::uint32_t _internal_number() const;
  void _internal_set_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.CSP_Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_Ping& from_msg);
    ::uint64_t timestamp_;
    ::uint32_t number_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_MapLoadEnd final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:jhnet.CSP_MapLoadEnd) */ {
 public:
  inline CSP_MapLoadEnd() : CSP_MapLoadEnd(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_MapLoadEnd* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_MapLoadEnd));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_MapLoadEnd(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_MapLoadEnd(const CSP_MapLoadEnd& from) : CSP_MapLoadEnd(nullptr, from) {}
  inline CSP_MapLoadEnd(CSP_MapLoadEnd&& from) noexcept
      : CSP_MapLoadEnd(nullptr, std::move(from)) {}
  inline CSP_MapLoadEnd& operator=(const CSP_MapLoadEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_MapLoadEnd& operator=(CSP_MapLoadEnd&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_MapLoadEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_MapLoadEnd* internal_default_instance() {
    return reinterpret_cast<const CSP_MapLoadEnd*>(
        &_CSP_MapLoadEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(CSP_MapLoadEnd& a, CSP_MapLoadEnd& b) { a.Swap(&b); }
  inline void Swap(CSP_MapLoadEnd* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_MapLoadEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_MapLoadEnd* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CSP_MapLoadEnd>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSP_MapLoadEnd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSP_MapLoadEnd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_MapLoadEnd"; }

 protected:
  explicit CSP_MapLoadEnd(::google::protobuf::Arena* arena);
  CSP_MapLoadEnd(::google::protobuf::Arena* arena, const CSP_MapLoadEnd& from);
  CSP_MapLoadEnd(::google::protobuf::Arena* arena, CSP_MapLoadEnd&& from) noexcept
      : CSP_MapLoadEnd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:jhnet.CSP_MapLoadEnd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_MapLoadEnd& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_Login final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.CSP_Login) */ {
 public:
  inline CSP_Login() : CSP_Login(nullptr) {}
  ~CSP_Login() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_Login* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_Login));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_Login(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_Login(const CSP_Login& from) : CSP_Login(nullptr, from) {}
  inline CSP_Login(CSP_Login&& from) noexcept
      : CSP_Login(nullptr, std::move(from)) {}
  inline CSP_Login& operator=(const CSP_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_Login& operator=(CSP_Login&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_Login* internal_default_instance() {
    return reinterpret_cast<const CSP_Login*>(
        &_CSP_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CSP_Login& a, CSP_Login& b) { a.Swap(&b); }
  inline void Swap(CSP_Login* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_Login* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_Login* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CSP_Login>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CSP_Login& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CSP_Login& from) { CSP_Login::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CSP_Login* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_Login"; }

 protected:
  explicit CSP_Login(::google::protobuf::Arena* arena);
  CSP_Login(::google::protobuf::Arena* arena, const CSP_Login& from);
  CSP_Login(::google::protobuf::Arena* arena, CSP_Login&& from) noexcept
      : CSP_Login(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLoginIdFieldNumber = 1,
    kLoginPwFieldNumber = 2,
  };
  // string login_id = 1;
  void clear_login_id() ;
  const std::string& login_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_login_id(Arg_&& arg, Args_... args);
  std::string* mutable_login_id();
  PROTOBUF_NODISCARD std::string* release_login_id();
  void set_allocated_login_id(std::string* value);

  private:
  const std::string& _internal_login_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_id(
      const std::string& value);
  std::string* _internal_mutable_login_id();

  public:
  // string login_pw = 2;
  void clear_login_pw() ;
  const std::string& login_pw() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_login_pw(Arg_&& arg, Args_... args);
  std::string* mutable_login_pw();
  PROTOBUF_NODISCARD std::string* release_login_pw();
  void set_allocated_login_pw(std::string* value);

  private:
  const std::string& _internal_login_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_pw(
      const std::string& value);
  std::string* _internal_mutable_login_pw();

  public:
  // @@protoc_insertion_point(class_scope:jhnet.CSP_Login)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      40, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_Login& from_msg);
    ::google::protobuf::internal::ArenaStringPtr login_id_;
    ::google::protobuf::internal::ArenaStringPtr login_pw_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_Echo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.CSP_Echo) */ {
 public:
  inline CSP_Echo() : CSP_Echo(nullptr) {}
  ~CSP_Echo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_Echo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_Echo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_Echo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_Echo(const CSP_Echo& from) : CSP_Echo(nullptr, from) {}
  inline CSP_Echo(CSP_Echo&& from) noexcept
      : CSP_Echo(nullptr, std::move(from)) {}
  inline CSP_Echo& operator=(const CSP_Echo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_Echo& operator=(CSP_Echo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_Echo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_Echo* internal_default_instance() {
    return reinterpret_cast<const CSP_Echo*>(
        &_CSP_Echo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CSP_Echo& a, CSP_Echo& b) { a.Swap(&b); }
  inline void Swap(CSP_Echo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_Echo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_Echo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CSP_Echo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CSP_Echo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CSP_Echo& from) { CSP_Echo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CSP_Echo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_Echo"; }

 protected:
  explicit CSP_Echo(::google::protobuf::Arena* arena);
  CSP_Echo(::google::protobuf::Arena* arena, const CSP_Echo& from);
  CSP_Echo(::google::protobuf::Arena* arena, CSP_Echo&& from) noexcept
      : CSP_Echo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kNumberFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // uint32 number = 1;
  void clear_number() ;
  ::uint32_t number() const;
  void set_number(::uint32_t value);

  private:
  ::uint32_t _internal_number() const;
  void _internal_set_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.CSP_Echo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      30, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_Echo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint32_t number_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_CreateChar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.CSP_CreateChar) */ {
 public:
  inline CSP_CreateChar() : CSP_CreateChar(nullptr) {}
  ~CSP_CreateChar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_CreateChar* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_CreateChar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_CreateChar(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_CreateChar(const CSP_CreateChar& from) : CSP_CreateChar(nullptr, from) {}
  inline CSP_CreateChar(CSP_CreateChar&& from) noexcept
      : CSP_CreateChar(nullptr, std::move(from)) {}
  inline CSP_CreateChar& operator=(const CSP_CreateChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_CreateChar& operator=(CSP_CreateChar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_CreateChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_CreateChar* internal_default_instance() {
    return reinterpret_cast<const CSP_CreateChar*>(
        &_CSP_CreateChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CSP_CreateChar& a, CSP_CreateChar& b) { a.Swap(&b); }
  inline void Swap(CSP_CreateChar* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_CreateChar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_CreateChar* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CSP_CreateChar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CSP_CreateChar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CSP_CreateChar& from) { CSP_CreateChar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CSP_CreateChar* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_CreateChar"; }

 protected:
  explicit CSP_CreateChar(::google::protobuf::Arena* arena);
  CSP_CreateChar(::google::protobuf::Arena* arena, const CSP_CreateChar& from);
  CSP_CreateChar(::google::protobuf::Arena* arena, CSP_CreateChar&& from) noexcept
      : CSP_CreateChar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kJobCodeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 job_code = 2;
  void clear_job_code() ;
  ::int32_t job_code() const;
  void set_job_code(::int32_t value);

  private:
  ::int32_t _internal_job_code() const;
  void _internal_set_job_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.CSP_CreateChar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      33, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_CreateChar& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t job_code_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_CharList final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:jhnet.CSP_CharList) */ {
 public:
  inline CSP_CharList() : CSP_CharList(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_CharList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_CharList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_CharList(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_CharList(const CSP_CharList& from) : CSP_CharList(nullptr, from) {}
  inline CSP_CharList(CSP_CharList&& from) noexcept
      : CSP_CharList(nullptr, std::move(from)) {}
  inline CSP_CharList& operator=(const CSP_CharList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_CharList& operator=(CSP_CharList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_CharList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_CharList* internal_default_instance() {
    return reinterpret_cast<const CSP_CharList*>(
        &_CSP_CharList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CSP_CharList& a, CSP_CharList& b) { a.Swap(&b); }
  inline void Swap(CSP_CharList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_CharList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_CharList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CSP_CharList>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSP_CharList& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSP_CharList& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_CharList"; }

 protected:
  explicit CSP_CharList(::google::protobuf::Arena* arena);
  CSP_CharList(::google::protobuf::Arena* arena, const CSP_CharList& from);
  CSP_CharList(::google::protobuf::Arena* arena, CSP_CharList&& from) noexcept
      : CSP_CharList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:jhnet.CSP_CharList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_CharList& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_Move final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_Move) */ {
 public:
  inline SCP_Move() : SCP_Move(nullptr) {}
  ~SCP_Move() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_Move* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_Move));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_Move(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_Move(const SCP_Move& from) : SCP_Move(nullptr, from) {}
  inline SCP_Move(SCP_Move&& from) noexcept
      : SCP_Move(nullptr, std::move(from)) {}
  inline SCP_Move& operator=(const SCP_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_Move& operator=(SCP_Move&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_Move* internal_default_instance() {
    return reinterpret_cast<const SCP_Move*>(
        &_SCP_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(SCP_Move& a, SCP_Move& b) { a.Swap(&b); }
  inline void Swap(SCP_Move* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_Move* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_Move& from) { SCP_Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_Move* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_Move"; }

 protected:
  explicit SCP_Move(::google::protobuf::Arena* arena);
  SCP_Move(::google::protobuf::Arena* arena, const SCP_Move& from);
  SCP_Move(::google::protobuf::Arena* arena, SCP_Move&& from) noexcept
      : SCP_Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosInfoFieldNumber = 2,
    kFieldUniqueFieldNumber = 1,
  };
  // .jhnet.PosInfo pos_info = 2;
  bool has_pos_info() const;
  void clear_pos_info() ;
  const ::jhnet::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::jhnet::PosInfo* release_pos_info();
  ::jhnet::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::jhnet::PosInfo* value);
  void unsafe_arena_set_allocated_pos_info(::jhnet::PosInfo* value);
  ::jhnet::PosInfo* unsafe_arena_release_pos_info();

  private:
  const ::jhnet::PosInfo& _internal_pos_info() const;
  ::jhnet::PosInfo* _internal_mutable_pos_info();

  public:
  // uint64 field_unique = 1;
  void clear_field_unique() ;
  ::uint64_t field_unique() const;
  void set_field_unique(::uint64_t value);

  private:
  ::uint64_t _internal_field_unique() const;
  void _internal_set_field_unique(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_Move& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::jhnet::PosInfo* pos_info_;
    ::uint64_t field_unique_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_CharList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_CharList) */ {
 public:
  inline SCP_CharList() : SCP_CharList(nullptr) {}
  ~SCP_CharList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_CharList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_CharList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_CharList(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_CharList(const SCP_CharList& from) : SCP_CharList(nullptr, from) {}
  inline SCP_CharList(SCP_CharList&& from) noexcept
      : SCP_CharList(nullptr, std::move(from)) {}
  inline SCP_CharList& operator=(const SCP_CharList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_CharList& operator=(SCP_CharList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_CharList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_CharList* internal_default_instance() {
    return reinterpret_cast<const SCP_CharList*>(
        &_SCP_CharList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SCP_CharList& a, SCP_CharList& b) { a.Swap(&b); }
  inline void Swap(SCP_CharList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_CharList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_CharList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_CharList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_CharList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_CharList& from) { SCP_CharList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_CharList* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_CharList"; }

 protected:
  explicit SCP_CharList(::google::protobuf::Arena* arena);
  SCP_CharList(::google::protobuf::Arena* arena, const SCP_CharList& from);
  SCP_CharList(::google::protobuf::Arena* arena, SCP_CharList&& from) noexcept
      : SCP_CharList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .jhnet.CharacterInfo characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;

  public:
  void clear_characters() ;
  ::jhnet::CharacterInfo* mutable_characters(int index);
  ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>* mutable_characters();

  private:
  const ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>& _internal_characters() const;
  ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>* _internal_mutable_characters();
  public:
  const ::jhnet::CharacterInfo& characters(int index) const;
  ::jhnet::CharacterInfo* add_characters();
  const ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>& characters() const;
  // @@protoc_insertion_point(class_scope:jhnet.SCP_CharList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_CharList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::jhnet::CharacterInfo > characters_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerInfo(const PlayerInfo& from) : PlayerInfo(nullptr, from) {}
  inline PlayerInfo(PlayerInfo&& from) noexcept
      : PlayerInfo(nullptr, std::move(from)) {}
  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
        &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(PlayerInfo& a, PlayerInfo& b) { a.Swap(&b); }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerInfo& from) { PlayerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.PlayerInfo"; }

 protected:
  explicit PlayerInfo(::google::protobuf::Arena* arena);
  PlayerInfo(::google::protobuf::Arena* arena, const PlayerInfo& from);
  PlayerInfo(::google::protobuf::Arena* arena, PlayerInfo&& from) noexcept
      : PlayerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kPosInfoFieldNumber = 3,
    kFieldUniqueFieldNumber = 1,
    kHpPercentFieldNumber = 4,
    kLookIdFieldNumber = 5,
  };
  // string nickname = 2;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // .jhnet.PosInfo pos_info = 3;
  bool has_pos_info() const;
  void clear_pos_info() ;
  const ::jhnet::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::jhnet::PosInfo* release_pos_info();
  ::jhnet::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::jhnet::PosInfo* value);
  void unsafe_arena_set_allocated_pos_info(::jhnet::PosInfo* value);
  ::jhnet::PosInfo* unsafe_arena_release_pos_info();

  private:
  const ::jhnet::PosInfo& _internal_pos_info() const;
  ::jhnet::PosInfo* _internal_mutable_pos_info();

  public:
  // uint64 field_unique = 1;
  void clear_field_unique() ;
  ::uint64_t field_unique() const;
  void set_field_unique(::uint64_t value);

  private:
  ::uint64_t _internal_field_unique() const;
  void _internal_set_field_unique(::uint64_t value);

  public:
  // int32 hp_percent = 4;
  void clear_hp_percent() ;
  ::int32_t hp_percent() const;
  void set_hp_percent(::int32_t value);

  private:
  ::int32_t _internal_hp_percent() const;
  void _internal_set_hp_percent(::int32_t value);

  public:
  // int32 look_id = 5;
  void clear_look_id() ;
  ::int32_t look_id() const;
  void set_look_id(::int32_t value);

  private:
  ::int32_t _internal_look_id() const;
  void _internal_set_look_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.PlayerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      33, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::jhnet::PosInfo* pos_info_;
    ::uint64_t field_unique_;
    ::int32_t hp_percent_;
    ::int32_t look_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class CSP_Move final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.CSP_Move) */ {
 public:
  inline CSP_Move() : CSP_Move(nullptr) {}
  ~CSP_Move() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CSP_Move* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CSP_Move));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CSP_Move(
      ::google::protobuf::internal::ConstantInitialized);

  inline CSP_Move(const CSP_Move& from) : CSP_Move(nullptr, from) {}
  inline CSP_Move(CSP_Move&& from) noexcept
      : CSP_Move(nullptr, std::move(from)) {}
  inline CSP_Move& operator=(const CSP_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSP_Move& operator=(CSP_Move&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSP_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSP_Move* internal_default_instance() {
    return reinterpret_cast<const CSP_Move*>(
        &_CSP_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(CSP_Move& a, CSP_Move& b) { a.Swap(&b); }
  inline void Swap(CSP_Move* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSP_Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSP_Move* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CSP_Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CSP_Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CSP_Move& from) { CSP_Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CSP_Move* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.CSP_Move"; }

 protected:
  explicit CSP_Move(::google::protobuf::Arena* arena);
  CSP_Move(::google::protobuf::Arena* arena, const CSP_Move& from);
  CSP_Move(::google::protobuf::Arena* arena, CSP_Move&& from) noexcept
      : CSP_Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosInfoFieldNumber = 1,
  };
  // .jhnet.PosInfo pos_info = 1;
  bool has_pos_info() const;
  void clear_pos_info() ;
  const ::jhnet::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::jhnet::PosInfo* release_pos_info();
  ::jhnet::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::jhnet::PosInfo* value);
  void unsafe_arena_set_allocated_pos_info(::jhnet::PosInfo* value);
  ::jhnet::PosInfo* unsafe_arena_release_pos_info();

  private:
  const ::jhnet::PosInfo& _internal_pos_info() const;
  ::jhnet::PosInfo* _internal_mutable_pos_info();

  public:
  // @@protoc_insertion_point(class_scope:jhnet.CSP_Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CSP_Move& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::jhnet::PosInfo* pos_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_Spawn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_Spawn) */ {
 public:
  inline SCP_Spawn() : SCP_Spawn(nullptr) {}
  ~SCP_Spawn() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_Spawn* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_Spawn));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_Spawn(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_Spawn(const SCP_Spawn& from) : SCP_Spawn(nullptr, from) {}
  inline SCP_Spawn(SCP_Spawn&& from) noexcept
      : SCP_Spawn(nullptr, std::move(from)) {}
  inline SCP_Spawn& operator=(const SCP_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_Spawn& operator=(SCP_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_Spawn* internal_default_instance() {
    return reinterpret_cast<const SCP_Spawn*>(
        &_SCP_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(SCP_Spawn& a, SCP_Spawn& b) { a.Swap(&b); }
  inline void Swap(SCP_Spawn* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_Spawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_Spawn* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_Spawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_Spawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_Spawn& from) { SCP_Spawn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_Spawn* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_Spawn"; }

 protected:
  explicit SCP_Spawn(::google::protobuf::Arena* arena);
  SCP_Spawn(::google::protobuf::Arena* arena, const SCP_Spawn& from);
  SCP_Spawn(::google::protobuf::Arena* arena, SCP_Spawn&& from) noexcept
      : SCP_Spawn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .jhnet.PlayerInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::jhnet::PlayerInfo* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>* mutable_players();

  private:
  const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>* _internal_mutable_players();
  public:
  const ::jhnet::PlayerInfo& players(int index) const;
  ::jhnet::PlayerInfo* add_players();
  const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>& players() const;
  // @@protoc_insertion_point(class_scope:jhnet.SCP_Spawn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_Spawn& from_msg);
    ::google::protobuf::RepeatedPtrField< ::jhnet::PlayerInfo > players_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_MyCharacterInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_MyCharacterInfo) */ {
 public:
  inline SCP_MyCharacterInfo() : SCP_MyCharacterInfo(nullptr) {}
  ~SCP_MyCharacterInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_MyCharacterInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_MyCharacterInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_MyCharacterInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_MyCharacterInfo(const SCP_MyCharacterInfo& from) : SCP_MyCharacterInfo(nullptr, from) {}
  inline SCP_MyCharacterInfo(SCP_MyCharacterInfo&& from) noexcept
      : SCP_MyCharacterInfo(nullptr, std::move(from)) {}
  inline SCP_MyCharacterInfo& operator=(const SCP_MyCharacterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_MyCharacterInfo& operator=(SCP_MyCharacterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_MyCharacterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_MyCharacterInfo* internal_default_instance() {
    return reinterpret_cast<const SCP_MyCharacterInfo*>(
        &_SCP_MyCharacterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(SCP_MyCharacterInfo& a, SCP_MyCharacterInfo& b) { a.Swap(&b); }
  inline void Swap(SCP_MyCharacterInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_MyCharacterInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_MyCharacterInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_MyCharacterInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_MyCharacterInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_MyCharacterInfo& from) { SCP_MyCharacterInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_MyCharacterInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_MyCharacterInfo"; }

 protected:
  explicit SCP_MyCharacterInfo(::google::protobuf::Arena* arena);
  SCP_MyCharacterInfo(::google::protobuf::Arena* arena, const SCP_MyCharacterInfo& from);
  SCP_MyCharacterInfo(::google::protobuf::Arena* arena, SCP_MyCharacterInfo&& from) noexcept
      : SCP_MyCharacterInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMyPlayerInfoFieldNumber = 1,
    kMyDetailInfoFieldNumber = 3,
    kMapIdFieldNumber = 2,
  };
  // .jhnet.PlayerInfo my_player_info = 1;
  bool has_my_player_info() const;
  void clear_my_player_info() ;
  const ::jhnet::PlayerInfo& my_player_info() const;
  PROTOBUF_NODISCARD ::jhnet::PlayerInfo* release_my_player_info();
  ::jhnet::PlayerInfo* mutable_my_player_info();
  void set_allocated_my_player_info(::jhnet::PlayerInfo* value);
  void unsafe_arena_set_allocated_my_player_info(::jhnet::PlayerInfo* value);
  ::jhnet::PlayerInfo* unsafe_arena_release_my_player_info();

  private:
  const ::jhnet::PlayerInfo& _internal_my_player_info() const;
  ::jhnet::PlayerInfo* _internal_mutable_my_player_info();

  public:
  // .jhnet.MyPlayerDetailInfo my_detail_info = 3;
  bool has_my_detail_info() const;
  void clear_my_detail_info() ;
  const ::jhnet::MyPlayerDetailInfo& my_detail_info() const;
  PROTOBUF_NODISCARD ::jhnet::MyPlayerDetailInfo* release_my_detail_info();
  ::jhnet::MyPlayerDetailInfo* mutable_my_detail_info();
  void set_allocated_my_detail_info(::jhnet::MyPlayerDetailInfo* value);
  void unsafe_arena_set_allocated_my_detail_info(::jhnet::MyPlayerDetailInfo* value);
  ::jhnet::MyPlayerDetailInfo* unsafe_arena_release_my_detail_info();

  private:
  const ::jhnet::MyPlayerDetailInfo& _internal_my_detail_info() const;
  ::jhnet::MyPlayerDetailInfo* _internal_mutable_my_detail_info();

  public:
  // int32 map_id = 2;
  void clear_map_id() ;
  ::int32_t map_id() const;
  void set_map_id(::int32_t value);

  private:
  ::int32_t _internal_map_id() const;
  void _internal_set_map_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_MyCharacterInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_MyCharacterInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::jhnet::PlayerInfo* my_player_info_;
    ::jhnet::MyPlayerDetailInfo* my_detail_info_;
    ::int32_t map_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};
// -------------------------------------------------------------------

class SCP_EnterGame final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:jhnet.SCP_EnterGame) */ {
 public:
  inline SCP_EnterGame() : SCP_EnterGame(nullptr) {}
  ~SCP_EnterGame() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SCP_EnterGame* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SCP_EnterGame));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SCP_EnterGame(
      ::google::protobuf::internal::ConstantInitialized);

  inline SCP_EnterGame(const SCP_EnterGame& from) : SCP_EnterGame(nullptr, from) {}
  inline SCP_EnterGame(SCP_EnterGame&& from) noexcept
      : SCP_EnterGame(nullptr, std::move(from)) {}
  inline SCP_EnterGame& operator=(const SCP_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCP_EnterGame& operator=(SCP_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCP_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCP_EnterGame* internal_default_instance() {
    return reinterpret_cast<const SCP_EnterGame*>(
        &_SCP_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(SCP_EnterGame& a, SCP_EnterGame& b) { a.Swap(&b); }
  inline void Swap(SCP_EnterGame* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCP_EnterGame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCP_EnterGame* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SCP_EnterGame>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SCP_EnterGame& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SCP_EnterGame& from) { SCP_EnterGame::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SCP_EnterGame* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "jhnet.SCP_EnterGame"; }

 protected:
  explicit SCP_EnterGame(::google::protobuf::Arena* arena);
  SCP_EnterGame(::google::protobuf::Arena* arena, const SCP_EnterGame& from);
  SCP_EnterGame(::google::protobuf::Arena* arena, SCP_EnterGame&& from) noexcept
      : SCP_EnterGame(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayersFieldNumber = 2,
    kMyPosInfoFieldNumber = 1,
  };
  // repeated .jhnet.PlayerInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::jhnet::PlayerInfo* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>* mutable_players();

  private:
  const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>* _internal_mutable_players();
  public:
  const ::jhnet::PlayerInfo& players(int index) const;
  ::jhnet::PlayerInfo* add_players();
  const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>& players() const;
  // .jhnet.PosInfo my_pos_info = 1;
  bool has_my_pos_info() const;
  void clear_my_pos_info() ;
  const ::jhnet::PosInfo& my_pos_info() const;
  PROTOBUF_NODISCARD ::jhnet::PosInfo* release_my_pos_info();
  ::jhnet::PosInfo* mutable_my_pos_info();
  void set_allocated_my_pos_info(::jhnet::PosInfo* value);
  void unsafe_arena_set_allocated_my_pos_info(::jhnet::PosInfo* value);
  ::jhnet::PosInfo* unsafe_arena_release_my_pos_info();

  private:
  const ::jhnet::PosInfo& _internal_my_pos_info() const;
  ::jhnet::PosInfo* _internal_mutable_my_pos_info();

  public:
  // @@protoc_insertion_point(class_scope:jhnet.SCP_EnterGame)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SCP_EnterGame& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::jhnet::PlayerInfo > players_;
    ::jhnet::PosInfo* my_pos_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jhnet_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PosInfo

// int32 x = 1;
inline void PosInfo::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t PosInfo::x() const {
  // @@protoc_insertion_point(field_get:jhnet.PosInfo.x)
  return _internal_x();
}
inline void PosInfo::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:jhnet.PosInfo.x)
}
inline ::int32_t PosInfo::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void PosInfo::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2;
inline void PosInfo::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t PosInfo::y() const {
  // @@protoc_insertion_point(field_get:jhnet.PosInfo.y)
  return _internal_y();
}
inline void PosInfo::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:jhnet.PosInfo.y)
}
inline ::int32_t PosInfo::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void PosInfo::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// int32 dir = 3;
inline void PosInfo::clear_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dir_ = 0;
}
inline ::int32_t PosInfo::dir() const {
  // @@protoc_insertion_point(field_get:jhnet.PosInfo.dir)
  return _internal_dir();
}
inline void PosInfo::set_dir(::int32_t value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:jhnet.PosInfo.dir)
}
inline ::int32_t PosInfo::_internal_dir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dir_;
}
inline void PosInfo::_internal_set_dir(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dir_ = value;
}

// -------------------------------------------------------------------

// CharacterInfo

// uint64 character_uid = 1;
inline void CharacterInfo::clear_character_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_uid_ = ::uint64_t{0u};
}
inline ::uint64_t CharacterInfo::character_uid() const {
  // @@protoc_insertion_point(field_get:jhnet.CharacterInfo.character_uid)
  return _internal_character_uid();
}
inline void CharacterInfo::set_character_uid(::uint64_t value) {
  _internal_set_character_uid(value);
  // @@protoc_insertion_point(field_set:jhnet.CharacterInfo.character_uid)
}
inline ::uint64_t CharacterInfo::_internal_character_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_uid_;
}
inline void CharacterInfo::_internal_set_character_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_uid_ = value;
}

// string nickname = 2;
inline void CharacterInfo::clear_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& CharacterInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.CharacterInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.CharacterInfo.nickname)
}
inline std::string* CharacterInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:jhnet.CharacterInfo.nickname)
  return _s;
}
inline const std::string& CharacterInfo::_internal_nickname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nickname_.Get();
}
inline void CharacterInfo::_internal_set_nickname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* CharacterInfo::_internal_mutable_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* CharacterInfo::release_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.CharacterInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void CharacterInfo::set_allocated_nickname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.CharacterInfo.nickname)
}

// int32 level = 3;
inline void CharacterInfo::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
}
inline ::int32_t CharacterInfo::level() const {
  // @@protoc_insertion_point(field_get:jhnet.CharacterInfo.level)
  return _internal_level();
}
inline void CharacterInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:jhnet.CharacterInfo.level)
}
inline ::int32_t CharacterInfo::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void CharacterInfo::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// int32 job_code = 4;
inline void CharacterInfo::clear_job_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_code_ = 0;
}
inline ::int32_t CharacterInfo::job_code() const {
  // @@protoc_insertion_point(field_get:jhnet.CharacterInfo.job_code)
  return _internal_job_code();
}
inline void CharacterInfo::set_job_code(::int32_t value) {
  _internal_set_job_code(value);
  // @@protoc_insertion_point(field_set:jhnet.CharacterInfo.job_code)
}
inline ::int32_t CharacterInfo::_internal_job_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_code_;
}
inline void CharacterInfo::_internal_set_job_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_code_ = value;
}

// -------------------------------------------------------------------

// PlayerInfo

// uint64 field_unique = 1;
inline void PlayerInfo::clear_field_unique() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_unique_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerInfo::field_unique() const {
  // @@protoc_insertion_point(field_get:jhnet.PlayerInfo.field_unique)
  return _internal_field_unique();
}
inline void PlayerInfo::set_field_unique(::uint64_t value) {
  _internal_set_field_unique(value);
  // @@protoc_insertion_point(field_set:jhnet.PlayerInfo.field_unique)
}
inline ::uint64_t PlayerInfo::_internal_field_unique() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_unique_;
}
inline void PlayerInfo::_internal_set_field_unique(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_unique_ = value;
}

// string nickname = 2;
inline void PlayerInfo::clear_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& PlayerInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.PlayerInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.PlayerInfo.nickname)
}
inline std::string* PlayerInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:jhnet.PlayerInfo.nickname)
  return _s;
}
inline const std::string& PlayerInfo::_internal_nickname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nickname_.Get();
}
inline void PlayerInfo::_internal_set_nickname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* PlayerInfo::_internal_mutable_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* PlayerInfo::release_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.PlayerInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void PlayerInfo::set_allocated_nickname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.PlayerInfo.nickname)
}

// .jhnet.PosInfo pos_info = 3;
inline bool PlayerInfo::has_pos_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_info_ != nullptr);
  return value;
}
inline void PlayerInfo::clear_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_info_ != nullptr) _impl_.pos_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::jhnet::PosInfo& PlayerInfo::_internal_pos_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::jhnet::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::jhnet::PosInfo&>(::jhnet::_PosInfo_default_instance_);
}
inline const ::jhnet::PosInfo& PlayerInfo::pos_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.PlayerInfo.pos_info)
  return _internal_pos_info();
}
inline void PlayerInfo::unsafe_arena_set_allocated_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jhnet.PlayerInfo.pos_info)
}
inline ::jhnet::PosInfo* PlayerInfo::release_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* released = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::jhnet::PosInfo* PlayerInfo::unsafe_arena_release_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.PlayerInfo.pos_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::jhnet::PosInfo* PlayerInfo::_internal_mutable_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::jhnet::PosInfo>(GetArena());
    _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(p);
  }
  return _impl_.pos_info_;
}
inline ::jhnet::PosInfo* PlayerInfo::mutable_pos_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::jhnet::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:jhnet.PlayerInfo.pos_info)
  return _msg;
}
inline void PlayerInfo::set_allocated_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pos_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:jhnet.PlayerInfo.pos_info)
}

// int32 hp_percent = 4;
inline void PlayerInfo::clear_hp_percent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_percent_ = 0;
}
inline ::int32_t PlayerInfo::hp_percent() const {
  // @@protoc_insertion_point(field_get:jhnet.PlayerInfo.hp_percent)
  return _internal_hp_percent();
}
inline void PlayerInfo::set_hp_percent(::int32_t value) {
  _internal_set_hp_percent(value);
  // @@protoc_insertion_point(field_set:jhnet.PlayerInfo.hp_percent)
}
inline ::int32_t PlayerInfo::_internal_hp_percent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hp_percent_;
}
inline void PlayerInfo::_internal_set_hp_percent(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_percent_ = value;
}

// int32 look_id = 5;
inline void PlayerInfo::clear_look_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.look_id_ = 0;
}
inline ::int32_t PlayerInfo::look_id() const {
  // @@protoc_insertion_point(field_get:jhnet.PlayerInfo.look_id)
  return _internal_look_id();
}
inline void PlayerInfo::set_look_id(::int32_t value) {
  _internal_set_look_id(value);
  // @@protoc_insertion_point(field_set:jhnet.PlayerInfo.look_id)
}
inline ::int32_t PlayerInfo::_internal_look_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.look_id_;
}
inline void PlayerInfo::_internal_set_look_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.look_id_ = value;
}

// -------------------------------------------------------------------

// MyPlayerDetailInfo

// int32 level = 1;
inline void MyPlayerDetailInfo::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
}
inline ::int32_t MyPlayerDetailInfo::level() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.level)
  return _internal_level();
}
inline void MyPlayerDetailInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.level)
}
inline ::int32_t MyPlayerDetailInfo::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void MyPlayerDetailInfo::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// int32 job_code = 2;
inline void MyPlayerDetailInfo::clear_job_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_code_ = 0;
}
inline ::int32_t MyPlayerDetailInfo::job_code() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.job_code)
  return _internal_job_code();
}
inline void MyPlayerDetailInfo::set_job_code(::int32_t value) {
  _internal_set_job_code(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.job_code)
}
inline ::int32_t MyPlayerDetailInfo::_internal_job_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_code_;
}
inline void MyPlayerDetailInfo::_internal_set_job_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_code_ = value;
}

// int64 exp = 3;
inline void MyPlayerDetailInfo::clear_exp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exp_ = ::int64_t{0};
}
inline ::int64_t MyPlayerDetailInfo::exp() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.exp)
  return _internal_exp();
}
inline void MyPlayerDetailInfo::set_exp(::int64_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.exp)
}
inline ::int64_t MyPlayerDetailInfo::_internal_exp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exp_;
}
inline void MyPlayerDetailInfo::_internal_set_exp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exp_ = value;
}

// int32 hp = 4;
inline void MyPlayerDetailInfo::clear_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = 0;
}
inline ::int32_t MyPlayerDetailInfo::hp() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.hp)
  return _internal_hp();
}
inline void MyPlayerDetailInfo::set_hp(::int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.hp)
}
inline ::int32_t MyPlayerDetailInfo::_internal_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hp_;
}
inline void MyPlayerDetailInfo::_internal_set_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = value;
}

// int32 max_hp = 5;
inline void MyPlayerDetailInfo::clear_max_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hp_ = 0;
}
inline ::int32_t MyPlayerDetailInfo::max_hp() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.max_hp)
  return _internal_max_hp();
}
inline void MyPlayerDetailInfo::set_max_hp(::int32_t value) {
  _internal_set_max_hp(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.max_hp)
}
inline ::int32_t MyPlayerDetailInfo::_internal_max_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_hp_;
}
inline void MyPlayerDetailInfo::_internal_set_max_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hp_ = value;
}

// int32 damage = 6;
inline void MyPlayerDetailInfo::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = 0;
}
inline ::int32_t MyPlayerDetailInfo::damage() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.damage)
  return _internal_damage();
}
inline void MyPlayerDetailInfo::set_damage(::int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.damage)
}
inline ::int32_t MyPlayerDetailInfo::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_;
}
inline void MyPlayerDetailInfo::_internal_set_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = value;
}

// int32 defense = 7;
inline void MyPlayerDetailInfo::clear_defense() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defense_ = 0;
}
inline ::int32_t MyPlayerDetailInfo::defense() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.defense)
  return _internal_defense();
}
inline void MyPlayerDetailInfo::set_defense(::int32_t value) {
  _internal_set_defense(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.defense)
}
inline ::int32_t MyPlayerDetailInfo::_internal_defense() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.defense_;
}
inline void MyPlayerDetailInfo::_internal_set_defense(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defense_ = value;
}

// int64 gold = 8;
inline void MyPlayerDetailInfo::clear_gold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gold_ = ::int64_t{0};
}
inline ::int64_t MyPlayerDetailInfo::gold() const {
  // @@protoc_insertion_point(field_get:jhnet.MyPlayerDetailInfo.gold)
  return _internal_gold();
}
inline void MyPlayerDetailInfo::set_gold(::int64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:jhnet.MyPlayerDetailInfo.gold)
}
inline ::int64_t MyPlayerDetailInfo::_internal_gold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gold_;
}
inline void MyPlayerDetailInfo::_internal_set_gold(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gold_ = value;
}

// -------------------------------------------------------------------

// CSP_Ping

// uint32 number = 1;
inline void CSP_Ping::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = 0u;
}
inline ::uint32_t CSP_Ping::number() const {
  // @@protoc_insertion_point(field_get:jhnet.CSP_Ping.number)
  return _internal_number();
}
inline void CSP_Ping::set_number(::uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:jhnet.CSP_Ping.number)
}
inline ::uint32_t CSP_Ping::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void CSP_Ping::_internal_set_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// uint64 timestamp = 2;
inline void CSP_Ping::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t CSP_Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:jhnet.CSP_Ping.timestamp)
  return _internal_timestamp();
}
inline void CSP_Ping::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:jhnet.CSP_Ping.timestamp)
}
inline ::uint64_t CSP_Ping::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void CSP_Ping::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// CSP_Echo

// uint32 number = 1;
inline void CSP_Echo::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = 0u;
}
inline ::uint32_t CSP_Echo::number() const {
  // @@protoc_insertion_point(field_get:jhnet.CSP_Echo.number)
  return _internal_number();
}
inline void CSP_Echo::set_number(::uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:jhnet.CSP_Echo.number)
}
inline ::uint32_t CSP_Echo::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void CSP_Echo::_internal_set_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// string message = 2;
inline void CSP_Echo::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CSP_Echo::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.CSP_Echo.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CSP_Echo::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.CSP_Echo.message)
}
inline std::string* CSP_Echo::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:jhnet.CSP_Echo.message)
  return _s;
}
inline const std::string& CSP_Echo::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void CSP_Echo::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CSP_Echo::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CSP_Echo::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.CSP_Echo.message)
  return _impl_.message_.Release();
}
inline void CSP_Echo::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.CSP_Echo.message)
}

// -------------------------------------------------------------------

// CSP_Login

// string login_id = 1;
inline void CSP_Login::clear_login_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_id_.ClearToEmpty();
}
inline const std::string& CSP_Login::login_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.CSP_Login.login_id)
  return _internal_login_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CSP_Login::set_login_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.CSP_Login.login_id)
}
inline std::string* CSP_Login::mutable_login_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_login_id();
  // @@protoc_insertion_point(field_mutable:jhnet.CSP_Login.login_id)
  return _s;
}
inline const std::string& CSP_Login::_internal_login_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.login_id_.Get();
}
inline void CSP_Login::_internal_set_login_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_id_.Set(value, GetArena());
}
inline std::string* CSP_Login::_internal_mutable_login_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.login_id_.Mutable( GetArena());
}
inline std::string* CSP_Login::release_login_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.CSP_Login.login_id)
  return _impl_.login_id_.Release();
}
inline void CSP_Login::set_allocated_login_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.login_id_.IsDefault()) {
    _impl_.login_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.CSP_Login.login_id)
}

// string login_pw = 2;
inline void CSP_Login::clear_login_pw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_pw_.ClearToEmpty();
}
inline const std::string& CSP_Login::login_pw() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.CSP_Login.login_pw)
  return _internal_login_pw();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CSP_Login::set_login_pw(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_pw_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.CSP_Login.login_pw)
}
inline std::string* CSP_Login::mutable_login_pw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_login_pw();
  // @@protoc_insertion_point(field_mutable:jhnet.CSP_Login.login_pw)
  return _s;
}
inline const std::string& CSP_Login::_internal_login_pw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.login_pw_.Get();
}
inline void CSP_Login::_internal_set_login_pw(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_pw_.Set(value, GetArena());
}
inline std::string* CSP_Login::_internal_mutable_login_pw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.login_pw_.Mutable( GetArena());
}
inline std::string* CSP_Login::release_login_pw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.CSP_Login.login_pw)
  return _impl_.login_pw_.Release();
}
inline void CSP_Login::set_allocated_login_pw(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_pw_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.login_pw_.IsDefault()) {
    _impl_.login_pw_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.CSP_Login.login_pw)
}

// -------------------------------------------------------------------

// CSP_CharList

// -------------------------------------------------------------------

// CSP_CreateChar

// string name = 1;
inline void CSP_CreateChar::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CSP_CreateChar::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.CSP_CreateChar.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CSP_CreateChar::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.CSP_CreateChar.name)
}
inline std::string* CSP_CreateChar::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:jhnet.CSP_CreateChar.name)
  return _s;
}
inline const std::string& CSP_CreateChar::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CSP_CreateChar::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CSP_CreateChar::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CSP_CreateChar::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.CSP_CreateChar.name)
  return _impl_.name_.Release();
}
inline void CSP_CreateChar::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.CSP_CreateChar.name)
}

// int32 job_code = 2;
inline void CSP_CreateChar::clear_job_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_code_ = 0;
}
inline ::int32_t CSP_CreateChar::job_code() const {
  // @@protoc_insertion_point(field_get:jhnet.CSP_CreateChar.job_code)
  return _internal_job_code();
}
inline void CSP_CreateChar::set_job_code(::int32_t value) {
  _internal_set_job_code(value);
  // @@protoc_insertion_point(field_set:jhnet.CSP_CreateChar.job_code)
}
inline ::int32_t CSP_CreateChar::_internal_job_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_code_;
}
inline void CSP_CreateChar::_internal_set_job_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_code_ = value;
}

// -------------------------------------------------------------------

// CSP_SelectChar

// uint64 character_uid = 1;
inline void CSP_SelectChar::clear_character_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_uid_ = ::uint64_t{0u};
}
inline ::uint64_t CSP_SelectChar::character_uid() const {
  // @@protoc_insertion_point(field_get:jhnet.CSP_SelectChar.character_uid)
  return _internal_character_uid();
}
inline void CSP_SelectChar::set_character_uid(::uint64_t value) {
  _internal_set_character_uid(value);
  // @@protoc_insertion_point(field_set:jhnet.CSP_SelectChar.character_uid)
}
inline ::uint64_t CSP_SelectChar::_internal_character_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_uid_;
}
inline void CSP_SelectChar::_internal_set_character_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_uid_ = value;
}

// -------------------------------------------------------------------

// CSP_MapLoadEnd

// -------------------------------------------------------------------

// CSP_Move

// .jhnet.PosInfo pos_info = 1;
inline bool CSP_Move::has_pos_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_info_ != nullptr);
  return value;
}
inline void CSP_Move::clear_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_info_ != nullptr) _impl_.pos_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::jhnet::PosInfo& CSP_Move::_internal_pos_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::jhnet::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::jhnet::PosInfo&>(::jhnet::_PosInfo_default_instance_);
}
inline const ::jhnet::PosInfo& CSP_Move::pos_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.CSP_Move.pos_info)
  return _internal_pos_info();
}
inline void CSP_Move::unsafe_arena_set_allocated_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jhnet.CSP_Move.pos_info)
}
inline ::jhnet::PosInfo* CSP_Move::release_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* released = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::jhnet::PosInfo* CSP_Move::unsafe_arena_release_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.CSP_Move.pos_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::jhnet::PosInfo* CSP_Move::_internal_mutable_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::jhnet::PosInfo>(GetArena());
    _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(p);
  }
  return _impl_.pos_info_;
}
inline ::jhnet::PosInfo* CSP_Move::mutable_pos_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::jhnet::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:jhnet.CSP_Move.pos_info)
  return _msg;
}
inline void CSP_Move::set_allocated_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pos_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:jhnet.CSP_Move.pos_info)
}

// -------------------------------------------------------------------

// SCP_Ping

// uint32 number = 1;
inline void SCP_Ping::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = 0u;
}
inline ::uint32_t SCP_Ping::number() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Ping.number)
  return _internal_number();
}
inline void SCP_Ping::set_number(::uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_Ping.number)
}
inline ::uint32_t SCP_Ping::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void SCP_Ping::_internal_set_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// uint64 timestamp = 2;
inline void SCP_Ping::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t SCP_Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Ping.timestamp)
  return _internal_timestamp();
}
inline void SCP_Ping::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_Ping.timestamp)
}
inline ::uint64_t SCP_Ping::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void SCP_Ping::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// SCP_Echo

// uint32 number = 1;
inline void SCP_Echo::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = 0u;
}
inline ::uint32_t SCP_Echo::number() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Echo.number)
  return _internal_number();
}
inline void SCP_Echo::set_number(::uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_Echo.number)
}
inline ::uint32_t SCP_Echo::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void SCP_Echo::_internal_set_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// string message = 2;
inline void SCP_Echo::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SCP_Echo::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Echo.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SCP_Echo::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.SCP_Echo.message)
}
inline std::string* SCP_Echo::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_Echo.message)
  return _s;
}
inline const std::string& SCP_Echo::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void SCP_Echo::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* SCP_Echo::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* SCP_Echo::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_Echo.message)
  return _impl_.message_.Release();
}
inline void SCP_Echo::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_Echo.message)
}

// -------------------------------------------------------------------

// SCP_Login

// bool login_ok = 1;
inline void SCP_Login::clear_login_ok() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_ok_ = false;
}
inline bool SCP_Login::login_ok() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Login.login_ok)
  return _internal_login_ok();
}
inline void SCP_Login::set_login_ok(bool value) {
  _internal_set_login_ok(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_Login.login_ok)
}
inline bool SCP_Login::_internal_login_ok() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.login_ok_;
}
inline void SCP_Login::_internal_set_login_ok(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_ok_ = value;
}

// string error_message = 2;
inline void SCP_Login::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& SCP_Login::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Login.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SCP_Login::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.SCP_Login.error_message)
}
inline std::string* SCP_Login::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_Login.error_message)
  return _s;
}
inline const std::string& SCP_Login::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void SCP_Login::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* SCP_Login::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* SCP_Login::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_Login.error_message)
  return _impl_.error_message_.Release();
}
inline void SCP_Login::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_Login.error_message)
}

// uint32 account_uid = 3;
inline void SCP_Login::clear_account_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_uid_ = 0u;
}
inline ::uint32_t SCP_Login::account_uid() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Login.account_uid)
  return _internal_account_uid();
}
inline void SCP_Login::set_account_uid(::uint32_t value) {
  _internal_set_account_uid(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_Login.account_uid)
}
inline ::uint32_t SCP_Login::_internal_account_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_uid_;
}
inline void SCP_Login::_internal_set_account_uid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_uid_ = value;
}

// -------------------------------------------------------------------

// SCP_CreateChar

// bool create_ok = 1;
inline void SCP_CreateChar::clear_create_ok() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.create_ok_ = false;
}
inline bool SCP_CreateChar::create_ok() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_CreateChar.create_ok)
  return _internal_create_ok();
}
inline void SCP_CreateChar::set_create_ok(bool value) {
  _internal_set_create_ok(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_CreateChar.create_ok)
}
inline bool SCP_CreateChar::_internal_create_ok() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.create_ok_;
}
inline void SCP_CreateChar::_internal_set_create_ok(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.create_ok_ = value;
}

// string error_message = 2;
inline void SCP_CreateChar::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& SCP_CreateChar::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_CreateChar.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SCP_CreateChar::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.SCP_CreateChar.error_message)
}
inline std::string* SCP_CreateChar::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_CreateChar.error_message)
  return _s;
}
inline const std::string& SCP_CreateChar::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void SCP_CreateChar::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* SCP_CreateChar::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* SCP_CreateChar::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_CreateChar.error_message)
  return _impl_.error_message_.Release();
}
inline void SCP_CreateChar::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_CreateChar.error_message)
}

// -------------------------------------------------------------------

// SCP_CharList

// repeated .jhnet.CharacterInfo characters = 1;
inline int SCP_CharList::_internal_characters_size() const {
  return _internal_characters().size();
}
inline int SCP_CharList::characters_size() const {
  return _internal_characters_size();
}
inline void SCP_CharList::clear_characters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.characters_.Clear();
}
inline ::jhnet::CharacterInfo* SCP_CharList::mutable_characters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_CharList.characters)
  return _internal_mutable_characters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>* SCP_CharList::mutable_characters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:jhnet.SCP_CharList.characters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_characters();
}
inline const ::jhnet::CharacterInfo& SCP_CharList::characters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_CharList.characters)
  return _internal_characters().Get(index);
}
inline ::jhnet::CharacterInfo* SCP_CharList::add_characters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::jhnet::CharacterInfo* _add = _internal_mutable_characters()->Add();
  // @@protoc_insertion_point(field_add:jhnet.SCP_CharList.characters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>& SCP_CharList::characters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:jhnet.SCP_CharList.characters)
  return _internal_characters();
}
inline const ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>&
SCP_CharList::_internal_characters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.characters_;
}
inline ::google::protobuf::RepeatedPtrField<::jhnet::CharacterInfo>*
SCP_CharList::_internal_mutable_characters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.characters_;
}

// -------------------------------------------------------------------

// SCP_SelectCharResult

// bool success = 1;
inline void SCP_SelectCharResult::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool SCP_SelectCharResult::success() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_SelectCharResult.success)
  return _internal_success();
}
inline void SCP_SelectCharResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_SelectCharResult.success)
}
inline bool SCP_SelectCharResult::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void SCP_SelectCharResult::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error_message = 2;
inline void SCP_SelectCharResult::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& SCP_SelectCharResult::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_SelectCharResult.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SCP_SelectCharResult::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:jhnet.SCP_SelectCharResult.error_message)
}
inline std::string* SCP_SelectCharResult::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_SelectCharResult.error_message)
  return _s;
}
inline const std::string& SCP_SelectCharResult::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void SCP_SelectCharResult::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* SCP_SelectCharResult::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* SCP_SelectCharResult::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_SelectCharResult.error_message)
  return _impl_.error_message_.Release();
}
inline void SCP_SelectCharResult::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_SelectCharResult.error_message)
}

// -------------------------------------------------------------------

// SCP_MyCharacterInfo

// .jhnet.PlayerInfo my_player_info = 1;
inline bool SCP_MyCharacterInfo::has_my_player_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.my_player_info_ != nullptr);
  return value;
}
inline void SCP_MyCharacterInfo::clear_my_player_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.my_player_info_ != nullptr) _impl_.my_player_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::jhnet::PlayerInfo& SCP_MyCharacterInfo::_internal_my_player_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::jhnet::PlayerInfo* p = _impl_.my_player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::jhnet::PlayerInfo&>(::jhnet::_PlayerInfo_default_instance_);
}
inline const ::jhnet::PlayerInfo& SCP_MyCharacterInfo::my_player_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_MyCharacterInfo.my_player_info)
  return _internal_my_player_info();
}
inline void SCP_MyCharacterInfo::unsafe_arena_set_allocated_my_player_info(::jhnet::PlayerInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.my_player_info_);
  }
  _impl_.my_player_info_ = reinterpret_cast<::jhnet::PlayerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jhnet.SCP_MyCharacterInfo.my_player_info)
}
inline ::jhnet::PlayerInfo* SCP_MyCharacterInfo::release_my_player_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PlayerInfo* released = _impl_.my_player_info_;
  _impl_.my_player_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::jhnet::PlayerInfo* SCP_MyCharacterInfo::unsafe_arena_release_my_player_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_MyCharacterInfo.my_player_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PlayerInfo* temp = _impl_.my_player_info_;
  _impl_.my_player_info_ = nullptr;
  return temp;
}
inline ::jhnet::PlayerInfo* SCP_MyCharacterInfo::_internal_mutable_my_player_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.my_player_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::jhnet::PlayerInfo>(GetArena());
    _impl_.my_player_info_ = reinterpret_cast<::jhnet::PlayerInfo*>(p);
  }
  return _impl_.my_player_info_;
}
inline ::jhnet::PlayerInfo* SCP_MyCharacterInfo::mutable_my_player_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::jhnet::PlayerInfo* _msg = _internal_mutable_my_player_info();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_MyCharacterInfo.my_player_info)
  return _msg;
}
inline void SCP_MyCharacterInfo::set_allocated_my_player_info(::jhnet::PlayerInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.my_player_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.my_player_info_ = reinterpret_cast<::jhnet::PlayerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_MyCharacterInfo.my_player_info)
}

// int32 map_id = 2;
inline void SCP_MyCharacterInfo::clear_map_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_id_ = 0;
}
inline ::int32_t SCP_MyCharacterInfo::map_id() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_MyCharacterInfo.map_id)
  return _internal_map_id();
}
inline void SCP_MyCharacterInfo::set_map_id(::int32_t value) {
  _internal_set_map_id(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_MyCharacterInfo.map_id)
}
inline ::int32_t SCP_MyCharacterInfo::_internal_map_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_id_;
}
inline void SCP_MyCharacterInfo::_internal_set_map_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_id_ = value;
}

// .jhnet.MyPlayerDetailInfo my_detail_info = 3;
inline bool SCP_MyCharacterInfo::has_my_detail_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.my_detail_info_ != nullptr);
  return value;
}
inline void SCP_MyCharacterInfo::clear_my_detail_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.my_detail_info_ != nullptr) _impl_.my_detail_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::jhnet::MyPlayerDetailInfo& SCP_MyCharacterInfo::_internal_my_detail_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::jhnet::MyPlayerDetailInfo* p = _impl_.my_detail_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::jhnet::MyPlayerDetailInfo&>(::jhnet::_MyPlayerDetailInfo_default_instance_);
}
inline const ::jhnet::MyPlayerDetailInfo& SCP_MyCharacterInfo::my_detail_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_MyCharacterInfo.my_detail_info)
  return _internal_my_detail_info();
}
inline void SCP_MyCharacterInfo::unsafe_arena_set_allocated_my_detail_info(::jhnet::MyPlayerDetailInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.my_detail_info_);
  }
  _impl_.my_detail_info_ = reinterpret_cast<::jhnet::MyPlayerDetailInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jhnet.SCP_MyCharacterInfo.my_detail_info)
}
inline ::jhnet::MyPlayerDetailInfo* SCP_MyCharacterInfo::release_my_detail_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jhnet::MyPlayerDetailInfo* released = _impl_.my_detail_info_;
  _impl_.my_detail_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::jhnet::MyPlayerDetailInfo* SCP_MyCharacterInfo::unsafe_arena_release_my_detail_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_MyCharacterInfo.my_detail_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jhnet::MyPlayerDetailInfo* temp = _impl_.my_detail_info_;
  _impl_.my_detail_info_ = nullptr;
  return temp;
}
inline ::jhnet::MyPlayerDetailInfo* SCP_MyCharacterInfo::_internal_mutable_my_detail_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.my_detail_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::jhnet::MyPlayerDetailInfo>(GetArena());
    _impl_.my_detail_info_ = reinterpret_cast<::jhnet::MyPlayerDetailInfo*>(p);
  }
  return _impl_.my_detail_info_;
}
inline ::jhnet::MyPlayerDetailInfo* SCP_MyCharacterInfo::mutable_my_detail_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::jhnet::MyPlayerDetailInfo* _msg = _internal_mutable_my_detail_info();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_MyCharacterInfo.my_detail_info)
  return _msg;
}
inline void SCP_MyCharacterInfo::set_allocated_my_detail_info(::jhnet::MyPlayerDetailInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.my_detail_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.my_detail_info_ = reinterpret_cast<::jhnet::MyPlayerDetailInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_MyCharacterInfo.my_detail_info)
}

// -------------------------------------------------------------------

// SCP_EnterGame

// .jhnet.PosInfo my_pos_info = 1;
inline bool SCP_EnterGame::has_my_pos_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.my_pos_info_ != nullptr);
  return value;
}
inline void SCP_EnterGame::clear_my_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.my_pos_info_ != nullptr) _impl_.my_pos_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::jhnet::PosInfo& SCP_EnterGame::_internal_my_pos_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::jhnet::PosInfo* p = _impl_.my_pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::jhnet::PosInfo&>(::jhnet::_PosInfo_default_instance_);
}
inline const ::jhnet::PosInfo& SCP_EnterGame::my_pos_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_EnterGame.my_pos_info)
  return _internal_my_pos_info();
}
inline void SCP_EnterGame::unsafe_arena_set_allocated_my_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.my_pos_info_);
  }
  _impl_.my_pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jhnet.SCP_EnterGame.my_pos_info)
}
inline ::jhnet::PosInfo* SCP_EnterGame::release_my_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* released = _impl_.my_pos_info_;
  _impl_.my_pos_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::jhnet::PosInfo* SCP_EnterGame::unsafe_arena_release_my_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_EnterGame.my_pos_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* temp = _impl_.my_pos_info_;
  _impl_.my_pos_info_ = nullptr;
  return temp;
}
inline ::jhnet::PosInfo* SCP_EnterGame::_internal_mutable_my_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.my_pos_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::jhnet::PosInfo>(GetArena());
    _impl_.my_pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(p);
  }
  return _impl_.my_pos_info_;
}
inline ::jhnet::PosInfo* SCP_EnterGame::mutable_my_pos_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::jhnet::PosInfo* _msg = _internal_mutable_my_pos_info();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_EnterGame.my_pos_info)
  return _msg;
}
inline void SCP_EnterGame::set_allocated_my_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.my_pos_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.my_pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_EnterGame.my_pos_info)
}

// repeated .jhnet.PlayerInfo players = 2;
inline int SCP_EnterGame::_internal_players_size() const {
  return _internal_players().size();
}
inline int SCP_EnterGame::players_size() const {
  return _internal_players_size();
}
inline void SCP_EnterGame::clear_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.players_.Clear();
}
inline ::jhnet::PlayerInfo* SCP_EnterGame::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_EnterGame.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>* SCP_EnterGame::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:jhnet.SCP_EnterGame.players)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_players();
}
inline const ::jhnet::PlayerInfo& SCP_EnterGame::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_EnterGame.players)
  return _internal_players().Get(index);
}
inline ::jhnet::PlayerInfo* SCP_EnterGame::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::jhnet::PlayerInfo* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:jhnet.SCP_EnterGame.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>& SCP_EnterGame::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:jhnet.SCP_EnterGame.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>&
SCP_EnterGame::_internal_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>*
SCP_EnterGame::_internal_mutable_players() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// SCP_Spawn

// repeated .jhnet.PlayerInfo players = 1;
inline int SCP_Spawn::_internal_players_size() const {
  return _internal_players().size();
}
inline int SCP_Spawn::players_size() const {
  return _internal_players_size();
}
inline void SCP_Spawn::clear_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.players_.Clear();
}
inline ::jhnet::PlayerInfo* SCP_Spawn::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_Spawn.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>* SCP_Spawn::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:jhnet.SCP_Spawn.players)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_players();
}
inline const ::jhnet::PlayerInfo& SCP_Spawn::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Spawn.players)
  return _internal_players().Get(index);
}
inline ::jhnet::PlayerInfo* SCP_Spawn::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::jhnet::PlayerInfo* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:jhnet.SCP_Spawn.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>& SCP_Spawn::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:jhnet.SCP_Spawn.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>&
SCP_Spawn::_internal_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::jhnet::PlayerInfo>*
SCP_Spawn::_internal_mutable_players() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// SCP_Despawn

// repeated uint64 field_unique = 1;
inline int SCP_Despawn::_internal_field_unique_size() const {
  return _internal_field_unique().size();
}
inline int SCP_Despawn::field_unique_size() const {
  return _internal_field_unique_size();
}
inline void SCP_Despawn::clear_field_unique() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_unique_.Clear();
}
inline ::uint64_t SCP_Despawn::field_unique(int index) const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Despawn.field_unique)
  return _internal_field_unique().Get(index);
}
inline void SCP_Despawn::set_field_unique(int index, ::uint64_t value) {
  _internal_mutable_field_unique()->Set(index, value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_Despawn.field_unique)
}
inline void SCP_Despawn::add_field_unique(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_field_unique()->Add(value);
  // @@protoc_insertion_point(field_add:jhnet.SCP_Despawn.field_unique)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& SCP_Despawn::field_unique() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:jhnet.SCP_Despawn.field_unique)
  return _internal_field_unique();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* SCP_Despawn::mutable_field_unique()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:jhnet.SCP_Despawn.field_unique)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_field_unique();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
SCP_Despawn::_internal_field_unique() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_unique_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* SCP_Despawn::_internal_mutable_field_unique() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.field_unique_;
}

// -------------------------------------------------------------------

// SCP_Move

// uint64 field_unique = 1;
inline void SCP_Move::clear_field_unique() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_unique_ = ::uint64_t{0u};
}
inline ::uint64_t SCP_Move::field_unique() const {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Move.field_unique)
  return _internal_field_unique();
}
inline void SCP_Move::set_field_unique(::uint64_t value) {
  _internal_set_field_unique(value);
  // @@protoc_insertion_point(field_set:jhnet.SCP_Move.field_unique)
}
inline ::uint64_t SCP_Move::_internal_field_unique() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_unique_;
}
inline void SCP_Move::_internal_set_field_unique(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_unique_ = value;
}

// .jhnet.PosInfo pos_info = 2;
inline bool SCP_Move::has_pos_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_info_ != nullptr);
  return value;
}
inline void SCP_Move::clear_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_info_ != nullptr) _impl_.pos_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::jhnet::PosInfo& SCP_Move::_internal_pos_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::jhnet::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::jhnet::PosInfo&>(::jhnet::_PosInfo_default_instance_);
}
inline const ::jhnet::PosInfo& SCP_Move::pos_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:jhnet.SCP_Move.pos_info)
  return _internal_pos_info();
}
inline void SCP_Move::unsafe_arena_set_allocated_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jhnet.SCP_Move.pos_info)
}
inline ::jhnet::PosInfo* SCP_Move::release_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* released = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::jhnet::PosInfo* SCP_Move::unsafe_arena_release_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:jhnet.SCP_Move.pos_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jhnet::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::jhnet::PosInfo* SCP_Move::_internal_mutable_pos_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::jhnet::PosInfo>(GetArena());
    _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(p);
  }
  return _impl_.pos_info_;
}
inline ::jhnet::PosInfo* SCP_Move::mutable_pos_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::jhnet::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:jhnet.SCP_Move.pos_info)
  return _msg;
}
inline void SCP_Move::set_allocated_pos_info(::jhnet::PosInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pos_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_info_ = reinterpret_cast<::jhnet::PosInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:jhnet.SCP_Move.pos_info)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace jhnet


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::jhnet::PacketId> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::jhnet::PacketId>() {
  return ::jhnet::PacketId_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // jhnet_2eproto_2epb_2eh
